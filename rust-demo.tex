\documentclass{acm_proc_article-sp}

\begin{document}
\title{Demo: The Rust Language and Type System}
\numberofauthors{2}
\author{
% 1st. author
\alignauthor
Felix S. Klock II\\
    \affaddr{Mozilla Research}\\
    \email{pnkfelix@mozilla.com}
% 2nd. author
\alignauthor
Nicholas Matsakis\\
    \affaddr{Mozilla Research}\\
    \email{nmatsakis@mozilla.com}
}
\maketitle

\section{Abstract}

\emph{Rust} is a new programming language for developing reliable and
efficient systems.  It is designed to support concurrency and
parallelism in building applications and libraries that take full
advantage of modern hardware.
 Rust's static type system is safe\footnote{Type soundness has not
  yet been formally proven for Rust, but type soundness is an
  explicit design goal for the language.} and expressive
and provides strong guarantees about isolation,
concurrency, and memory safety.

Rust also offers a clear performance model, making it easier to
predict and reason about program efficiency.  One important way it
accomplishes this is by allowing fine-grained control over memory
representations, with direct support for stack allocation and
contiguous record storage.  The language balances such controls with
the absolute requirement for safety: Rust's type system and runtime
guarantee the absence of data races, buffer overflows, stack overflows,
and accesses to uninitialized or deallocated memory.

In this demonstration, we will briefly review the language features
that Rust leverages to accomplish the above goals, focusing in
particular on Rust's advanced type system, and then show a collection
of concrete examples of program subroutines that are efficient, easy
for programmers to reason about, and maintain the above safety
property.

If time permits, we will also show the current state of \emph{Servo},
Mozilla's research web browser that is implemented in Rust.

\keywords{Rust, Systems programming, Memory management, Affine type systems}

\section{Memory Manipulation in Rust}

Rust shares several features with the ML family of languages,
such as algebraic data types and parametric polymorphism.  The syntax
and semantics for simple Rust programs can be explained via
analogy with corresponding ML programs.

However, Rust also deviates from ML in a number of ways.  For this
demonstration, we will focus on Rust's approach to managing
memory, which is quite different from that of ML.
In Rust, one can allocate objects inline within other objects;
also, a Rust program may work with (potentially mutable) references into the
middle of allocated blocks of memory, \emph{including} blocks that represent
particular variants of an algebraic type.
This introduces the potential for non-local aliasing;
such aliasing, if left unconstrained, would yield type soundness holes.%
\footnote{One can also express ref-cells (ML's {\tt ref}) and
  arrays of boxed values in Rust; however, inline
  allocation and interior pointers are important systems
  programming features.}

To control aliasing and ensure type soundness, Rust uses an affine
type system that tracks ownership.  The unique owner of an object can
hand that ownership off to new owner; but the owner may instead hand
off {\em borrowed references} to (or into) the object.  These
so-called \emph{borrows} obey lexical scope, ensuring that when the
original reference goes out of scope, there will not be any
outstanding borrowed references to the object (otherwise known as
``dangling pointers'').  This also implies that when the owner goes
out of scope or is otherwise deallocated, the referenced object can be
deallocated at the same time. Rust leverages the latter property by
adding support for user-defined destructors, enabling RAII\footnote{%
RAII: ``Resource Acquisition Is Initialization''}
patterns as popularized by C++.

There are two flavors of borrows: mutable and immutable.
Mut\-able references have a uniqueness property:
There can be at
most one active mutable borrow of a given piece of state (the owner
itself is not allowed to mutate the object for the duration of the
mutable borrow, nor are any of the inactive mutable borrows).
Immutable references, on the other hand,
can be freely copied, and their referents can be the source for new
immutable borrows (subject to the restriction that all borrows
still respect the lexical scope of the object's owner).

Rust functions can manipulate objects that are owned by local
variables arbitrarily far up the control stack.  Such functions need to
support operations like {\tt *ptr1 = *ptr2;} (writing the dereferenced
value of {\tt ptr2} into the memory referenced by {\tt ptr1}), but must
also respect the rules: such assignment statements
must be prohibited from injecting dangling pointers.

A function that manipulates borrowed references needs to
constrain its input parameters to ensure that
executing the function body will not break the rules.
%
Rust has an optional explicit syntax for describing the {\em lifetime}
bounds associated with a reference. Lifetime bounds mix together with
{\em lifetime-{}polymorphism} (analogous to {\em type-polymorphism})
to provide functions the expressive power needed to manipulate
memory references, without breaking type safety.

\section{Demonstration Outline}

Planned topics for the demonstration include:
\begin{itemize}
\item Memory safety in Rust
\item Ownership and linear types
\begin{itemize}
\item Data Allocation
\item Deallocation and (User-defined) Destructors
\item Inherited mutability
\item Moving and sending data
\end{itemize}
\item Borrowing and freezing of mutable data structures
\begin{itemize}
\item The necessity of (controlled, temporary) aliasing
\item Explicit and implicit lifetime parameters
\end{itemize}
\item Discussion of design space
\begin{itemize}
\item Comparison against other work
\item Moving values based on type, vs {\tt move} keyword
\item Linear mutable values
\item Lexically scoped lifetimes
\end{itemize}
\end{itemize}
\end{document}
